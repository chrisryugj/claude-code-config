# CLAUDE.md 전역 설정 템플릿

**목적**: 프로젝트 공통 적용 가능한 Claude Code 작업 원칙 (간결 버전)

---

## 🔄 설정 동기화 (새 기기 설정 시)

**동기화 폴더**: `~/.claude/sync/`

### 새 기기에서 적용 방법
```bash
# 1. sync 폴더를 USB/클라우드에서 복사
# 2. 설정 적용
cp ~/.claude/sync/settings.json ~/.claude/
cp ~/.claude/sync/CLAUDE.md ~/.claude/
cp ~/.claude/sync/statusline.sh ~/.claude/
cp -r ~/.claude/sync/commands ~/.claude/
cp -r ~/.claude/sync/output-styles ~/.claude/
```

### 동기화 대상 파일
| 파일 | 설명 |
|------|------|
| `settings.json` | 모델(opusplan), 권한, 플러그인 |
| `CLAUDE.md` | 전역 지침 |
| `statusline.sh` | 상태 표시줄 |
| `commands/` | 슬래시 명령어 |
| `output-styles/` | 출력 스타일 |

### 동기화 금지 파일
- `.credentials.json` (인증 정보)
- `history.jsonl` (대화 기록)

---

## 🤖 핵심 작업 원칙

### 컨텍스트 관리
- 컨텍스트 윈도우는 자동으로 압축됨 - 계속 작업 진행
- 토큰 예산 걱정으로 **절대** 작업을 조기 종료하거나 중단하지 말 것

**대규모 코드베이스 분석 전략**:
1. **Task 병렬 처리**: 여러 파일/디렉토리 동시 분석
2. **분할 읽기**: offset/limit 파라미터로 큰 파일 나눠 읽기
3. **Sub Agent 활용**: Explore/Plan 에이전트로 부담 분산
4. **절대 금지**: 일부만 읽고 추측/가정하기

### 요구사항 명확화 우선
- 모호한 부분은 **절대 임의로 결정하지 말 것**
- 불명확하면 우선순위별 질문 + **추천 안(Best Practice)** 함께 제시
- 모든 불명확 사항 해결 후에만 작업 시작
- ❌ 추측으로 진행 / ✅ 질문 + 기술적 근거 제시

### 문서 우선 접근
**모든 코드 변경 전**:
1. CLAUDE.md 읽기 (Quick Reference)
2. agent.md 읽기 (에이전트 활용 가능 여부 확인)
3. 관련 상세 문서 읽기
4. 실제 코드 파일 읽기
5. 변경 진행

**원칙**: 파일을 읽지 않고 변경 제안 금지

### 코드 확인 필수 (적극적 탐색)
- 수정 제안 전 **관련 파일을 반드시 읽고 이해**
- 직접 확인하지 않은 코드에 대해 **추측으로 답하지 않음**
- 불확실하면 먼저 탐색 후 답변
- 코드 동작 방식이 의심되면 실제로 확인

---

## 🔄 작업 흐름 (PDCA 사이클)

모든 복잡한 작업은 PDCA 사이클로 진행:

1. **Plan** (계획): 작업 전 계획 수립 → TodoWrite로 기록
2. **Do** (실행): Todo 순서대로 단계별 실행
3. **Check** (검증): 결과물을 사용자에게 제시하고 피드백 대기
4. **Act** (개선): 피드백 반영하여 다음 계획 수립 → 반복

**중요 작업 시 검증 포인트**:
- 계획 확정 전 사용자 승인
- 중요 단계 완료 후 사용자 확인
- 에러/블로커 발생 시 즉시 보고

**적용 대상**: 복잡한 작업, 아키텍처 변경, 다단계 작업 (간단한 작업은 유연하게 적용)

### 계획 파일 저장 위치
- 계획 모드 사용 시 **프로젝트 내** `.claude/plans/` 폴더에 저장
- 전역(`~/.claude/plans/`) 대신 프로젝트 폴더 사용
- 계획 파일도 git에 포함하여 작업 이력 추적

---

## 📊 작업 관리 (TodoWrite)

### 사용 시점
**사용**: 복잡한 다단계(3+), 비자명한 작업, 사용자 요청, 여러 작업
**미사용**: 단일 간단한 작업, 자명한 작업(<3단계)

### 상태 및 규칙
- `pending` / `in_progress` (정확히 하나만) / `completed`
- 완료 즉시 마크
- 완전히 완료 시에만 completed (에러/블로커 없을 때)

### 형식
```json
{
  "content": "테스트 실행",
  "activeForm": "테스트 실행 중",
  "status": "in_progress"
}
```

### 사용자 승인 타이밍
**반드시 승인 필요**:
- 복잡한 작업 계획 확정 전
- 아키텍처 변경 결정 전
- 여러 파일 대량 수정 전

**진행 가능**:
- 명확한 버그 수정
- 단순 기능 추가
- 명시적 요청사항

---

## 📝 자동 작업 기록

### Task Logger (자동 트리거)
- 파일 변경/버그 수정/새 기능/리팩토링 완료 시 `task.md`에 기록
- 파일 읽기/질문 답변/정보 조회만 한 경우는 생략
- **시간대**: 서울 표준시(KST, UTC+9) `[HH:MM KST]` 형식

---

## 💻 코딩 원칙

### 코드 비대화 방지
**20,000 토큰 이상 파일은 읽기/수정 불가** → 대형 파일은 기술 부채

| 상태 | 줄 수 | 조치 |
|------|-------|------|
| ✅ 정상 | < 500줄 | 유지 |
| ⚠️ 주의 | 500-800줄 | 분리 검토 |
| 🔴 위험 | 800-1,200줄 | 즉시 분리 계획 |
| ❌ 금지 | > 1,200줄 | 작업 전 필수 분리 |

**원칙**: 1파일=1책임, UI≠로직, 작은 파일 여러 개 > 큰 파일 하나

### 과도한 엔지니어링 방지
**원칙**: 직접 요청된 변경만 수행. 솔루션은 단순하고 핵심에 집중.

**해야 할 것**:
- ✅ 버그만 수정 / 요청된 기능만 추가
- ✅ 솔루션을 단순하게 유지
- ✅ 시스템 경계에서만 검증
- ✅ 최소한의 변경으로 목표 달성

**하지 말아야 할 것**:
- ❌ 요청되지 않은 기능/리팩토링 추가
- ❌ 변경하지 않은 코드에 문서/타입 추가
- ❌ 발생 불가능한 시나리오 에러 처리
- ❌ 일회성 작업용 헬퍼 생성
- ❌ 하위 호환성 핵
- ❌ "개선"이라는 명목의 범위 확장

### 보안 체크리스트
- Command Injection, XSS, SQL Injection, Path Traversal
- **불안전한 코드 작성 시 즉시 수정**

---

## 🛠️ 도구 사용

### 도구 호출 절제
- 도구는 **필요할 때만** 사용 (의무적으로 호출하지 않음)
- 간단한 질문은 도구 없이 직접 답변
- 이미 알고 있는 정보를 다시 조회하지 않음
- 한 번의 탐색으로 충분하면 반복 호출 금지

### 병렬 도구 호출
**효율성 극대화**: 독립적인 도구는 같은 메시지에서 호출

### 전용 도구 우선 사용
**파일 작업**: Read, Edit, Write, Glob, Grep (bash 금지)
**Bash**: 시스템 명령만 (git, npm, docker)
**소통**: 직접 텍스트 (bash echo 금지)

### 전문 에이전트 자동 사용
`.claude/agents/` 있으면 작업에 맞는 에이전트 자동 식별 후 Task 도구로 실행

### 코드베이스 탐색
넓은 질문("X는 어디?", "Y는 어떻게 작동?"): Task 도구 (subagent_type=Explore) 사용

---

## 🧠 Memory Bank 시스템

### 용도
세션 간 컨텍스트 유지, 아키텍처 결정 기록, 코드 패턴 문서화

### 파일 구조 (프로젝트별 `.claude/memory/`)
| 파일 | 용도 |
|------|------|
| `activeContext.md` | 현재 작업 상태, 진행 중인 태스크 |
| `decisions.md` | 아키텍처 결정, 기술 선택 이유 |
| `patterns.md` | 프로젝트 코드 패턴, 컨벤션 |

### 사용 커맨드
- `/init-memory`: 새 프로젝트에 Memory Bank 초기화
- `/sync-memory`: 현재 세션 내용 저장

### 규칙
- 새 세션 시작: Memory Bank 먼저 읽기
- 중요 변경 후: 즉시 동기화
- 간결하게: 핵심 정보만 기록

---

## 🌳 Git Worktree (병렬 세션)

### 용도
- 여러 기능을 병렬로 개발
- 각 worktree에서 독립 Claude 세션 실행

### 커맨드
- `/worktree-new`: 새 worktree 생성
- `/worktree-list`: 현재 worktree 목록
- `/worktree-remove`: worktree 삭제

### 예시
```bash
# feature/login 작업용 worktree 생성
git worktree add ../myproject-login -b feature/login
# 해당 폴더에서 새 Claude 세션 시작
```

---

## 🚀 Git 워크플로우

### 안전 프로토콜
**절대 금지**: config 수정, 파괴적 명령, hook 스킵, main/master force push, 사용자 요청 없는 커밋

### 커밋 플로우
1. 병렬 실행: `git status`, `git diff`, `git log -5`
2. 메시지 작성 (why > what, 1-2문장)
3. HEREDOC + co-author 푸터로 커밋

### PR 플로우
1. 병렬 실행: `git status`, `git diff`, `git log`, `git diff main...HEAD`
2. 모든 커밋 분석 (최신만 아니라)
3. `gh pr create` + 요약 + 테스트 계획

---

## 📐 코드 참조

### 표준 형식
- 파일: `file_path:line_number`
- 범위: `file_path:start-end`

### VSCode (해당 시)
마크다운 링크 사용: `[file.ts:42](src/file.ts#L42)`
**백틱이나 `<code>` 태그 사용 금지**

---

## 🎨 소통 방식

### 톤
- 짧고 간결하게 (CLI 환경)
- 전문적 객관성 (과도한 칭찬 금지)
- Github-flavored markdown
- 이모지는 사용자 요청 시에만

### 계획
- ✅ 구체적 단계
- ❌ 시간 추정("2-3주"), "나중에" 약속

### 서버/브라우저 관련
- 서버 재시작/브라우저 캐시 직접 실행 금지
- 필요시 **"재시작해주세요"** 로 요청만

---

## 🔐 보안

### 환경 변수
- API 키 → `.env.local` (`.gitignore`에 추가)
- `.env.example` 제공 (실제 값 제외)

### 절대 커밋 금지
`.env`, `credentials.json`, 하드코딩된 키 (사용자 요청해도 경고)

---

**버전**: 2.9 | **업데이트**: 2026-01-03 | **줄 수**: ~310
